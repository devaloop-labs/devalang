"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = parse;
exports.debug_render = debug_render;
exports.render_audio = render_audio;
exports.register_playhead_callback = register_playhead_callback;
exports.collect_playhead_events = collect_playhead_events;
exports.unregister_playhead_callback = unregister_playhead_callback;
let wasmPkg = undefined;
try {
    // prefer runtime pkg generated by wasm-pack when available
    // require at runtime so the package can be used even if wasm hasn't been built
    // (this keeps tests and consumers robust).
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    wasmPkg = require("../../pkg/devalang_core");
}
catch (_e) {
    wasmPkg = undefined;
}
/**
 * Parses the user code.
 * @param entry_path The entry path for the code.
 * @param source The source code to parse.
 * @returns ParseResult | any
 */
function parse(entry_path, source) {
    if (wasmPkg && typeof wasmPkg.parse === "function") {
        return wasmPkg.parse(entry_path, source);
    }
    throw new Error("WASM binding 'parse' not available. Build the wasm package or use the JS runtime.");
}
/**
 * Renders the debug information for the user code.
 * @param user_code The user-provided code to render debug information for.
 * @returns DebugResult | any
 */
function debug_render(user_code) {
    if (wasmPkg && typeof wasmPkg.debug_render === "function") {
        return wasmPkg.debug_render(user_code);
    }
    throw new Error("WASM binding 'debug_render' not available. Build the wasm package or use the JS runtime.");
}
/**
 * Renders audio from the user code.
 * @param user_code The user-provided code to render audio from.
 * @returns Float32Array
 */
function render_audio(user_code) {
    if (wasmPkg && typeof wasmPkg.render_audio === "function") {
        return wasmPkg.render_audio(user_code);
    }
    // Fallback: indicate missing wasm with an empty buffer rather than breaking consumers.
    return new Float32Array(0);
}
/**
 * Register a JS callback to receive playhead events { time, line, column } during playback.
 * The callback will be called with a single object argument.
 * @param cb The callback function to register.
 * @returns void
 */
function register_playhead_callback(cb) {
    if (wasmPkg && typeof wasmPkg.register_playhead_callback === "function") {
        return wasmPkg.register_playhead_callback(cb);
    }
    // no-op fallback
    return;
}
/**
 * Collects playhead events that have been recorded during playback.
 * @returns Array of playhead events { time, line, column }.
 */
function collect_playhead_events() {
    if (wasmPkg && typeof wasmPkg.collect_playhead_events === "function") {
        return wasmPkg.collect_playhead_events();
    }
    return [];
}
/**
 * Unregisters the JS callback for playhead events.
 * @returns void
 */
function unregister_playhead_callback() {
    if (wasmPkg && typeof wasmPkg.unregister_playhead_callback === "function") {
        return wasmPkg.unregister_playhead_callback();
    }
    return;
}
